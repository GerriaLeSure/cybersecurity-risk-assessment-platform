import socket
import ssl
import requests
import logging
import json
import random
from datetime import datetime

# Setup logging
logging.basicConfig(filename='security_scan.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# CVE Mockup DB (Placeholder)
MOCK_CVE_DB = {
    "OpenSSH": "CVE-2022-1234",
    "Apache": "CVE-2023-5678",
    "Nginx": "CVE-2021-7890"
}

# Severity mapping
SEVERITY_MAP = {
    "Critical": 90,
    "High": 70,
    "Medium": 40,
    "Low": 10
}

# Risk scoring AI logic (simplified)
def classify_risk(score: int) -> str:
    if score >= 90:
        return "Critical"
    elif score >= 70:
        return "High"
    elif score >= 40:
        return "Medium"
    else:
        return "Low"

# ==== Network Scanner ====
def port_scan(host: str, ports: list):
    open_ports = []
    for port in ports:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            if result == 0:
                open_ports.append(port)
            sock.close()
        except Exception as e:
            logging.error(f"Port scan error on port {port}: {str(e)}")
    return open_ports

# ==== SSL/TLS Scanner ====
def check_ssl_cert(host: str):
    try:
        context = ssl.create_default_context()
        conn = context.wrap_socket(socket.socket(), server_hostname=host)
        conn.settimeout(3)
        conn.connect((host, 443))
        cert = conn.getpeercert()
        conn.close()
        return {
            "issuer": cert.get('issuer'),
            "notBefore": cert.get('notBefore'),
            "notAfter": cert.get('notAfter'),
        }
    except Exception as e:
        logging.error(f"SSL check failed: {e}")
        return None

# ==== Vulnerability Detection ====
def detect_common_vulnerabilities(services: list):
    findings = []
    for service in services:
        cve = MOCK_CVE_DB.get(service, None)
        if cve:
            severity = random.choice(list(SEVERITY_MAP.keys()))
            findings.append({
                "service": service,
                "cve": cve,
                "description": f"Known vulnerability in {service}.",
                "severity": severity,
                "risk_score": SEVERITY_MAP[severity]
            })
    return findings

# ==== Web App Scanner (Basic) ====
def basic_web_scan(url: str):
    issues = []
    try:
        response = requests.get(url)
        if 'X-Frame-Options' not in response.headers:
            issues.append("Missing X-Frame-Options header.")
        if 'Content-Security-Policy' not in response.headers:
            issues.append("Missing Content-Security-Policy header.")
        if 'Server' in response.headers:
            issues.append(f"Server header exposed: {response.headers['Server']}")
    except Exception as e:
        logging.error(f"Web scan failed for {url}: {str(e)}")
    return issues

# ==== Compliance Checker ====
def check_compliance(policies: list):
    results = {
        "SOC2": "SOC2" in policies,
        "ISO27001": "ISO27001" in policies,
        "GDPR": "GDPR" in policies,
        "NIST": "NIST" in policies
    }
    return results

# ==== AI Threat Analysis (Mock) ====
def ai_threat_analysis(indicators: list):
    threat_score = sum([random.randint(10, 30) for _ in indicators])
    threat_level = classify_risk(threat_score)
    return {
        "anomaly_detected": threat_score > 60,
        "risk_score": threat_score,
        "risk_level": threat_level,
        "threat_indicators": indicators,
        "summary": f"{threat_level} risk identified based on {len(indicators)} indicators."
    }

# ==== Main Orchestrator ====
def run_full_security_scan(domain: str, ports: list, web_url: str, services: list, policies: list, indicators: list):
    logging.info(f"Starting full scan for {domain}")
    return {
        "ssl_cert_info": check_ssl_cert(domain),
        "open_ports": port_scan(domain, ports),
        "vulnerabilities": detect_common_vulnerabilities(services),
        "web_issues": basic_web_scan(web_url),
        "compliance": check_compliance(policies),
        "threat_analysis": ai_threat_analysis(indicators)
    }
